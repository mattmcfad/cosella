//--------------------
// Make sure cells are same icon
var case0 = {

	// Make sure both cells are actually same type of icon
	test: function(first,second) {
		// If either id has matched 
		if (first.solved === true || second.solved === true)
			return false;
		return (first.id === second.id) ? true : false;
	}
};;//--------------------
// Test if two cells are on same row or column
var case1 = {
	
	test: function(first,second) {
		
		var cordX = first.x, cordY = first.y, solved = false, cell;

		// If they are both on same column
		if (first.x === second.x) {

			// If selected [1]
			//			    .
			//	       		.
			//	 		   [2]
			if (first.y < second.y){
				while (cordY < second.y){
					cordY++;
					cell = $('#'+app.getId(cordX,cordY));
					if(cordY === second.y){
						solved = true;
						break;
					}
					else if (cell.data().solved === false){
						solved = false;
						break;
					}
				}
			}

			//if selected [2]
			//			   .
			//			   .
			//			  [1]
			if (first.y > second.y){
				while (cordY > second.y){
					cordY--;
					cell = $('#'+app.getId(cordX,cordY));
					if(cordY === second.y){
						
						solved = true;
						break;
					}
					else if (cell.data().solved === false){
						
						solved = false;
						break;
					}
				}
			}
		}

		/*************************/

		//if they are both on the same row
		else if (first.y === second.y){
			//
			// If selected [1] .... [2]
			//
			if (first.x < second.x){
				while (cordX < second.x){
					cordX++;
					cell = $('#'+app.getId(cordX,cordY));
					if (cordX === second.x){
						
						solved = true;
						break;
					}

					if (cell.data().solved === false){
						
						solved = false;
						break;
					}
				}
			}
			//
			// Else selected [2] .... [1]
			//
			else if (first.x > second.x){
				while (cordX > second.x){
					cordX--;
					cell = $('#'+app.getId(cordX,cordY));
					if (cordX === second.x){
						//console.log('match!');
						solved = true;
						break;
					}
					if (cell.data().solved === false){
						
						solved = false;
						break;
					}
				}
			}
		}
		if (solved === true){
			app.matchSuccess(first,second);
			return true;

		}
		else {
			
			return false;
		}
	}// case1
};;//--------------------
// Test if a U shaped path has occurred
var case2 = {

	// U shape algorithm
	test: function(first,second) {
		var cordX = first.x, cordY = first.y, tempX, tempY, solved = false, cell;
		//console.log("=================================");
		
		//--------------------
		// initialize algorithm
		function init() {
			cordX = first.x; 
			cordY = first.y;
			solved = false;
		}

		// CASE A & B
		if (first.x < second.x){
			//console.log("hit case A & B");


			// *********    CASE A    **********   
			//
			//  ............. 	 .....[2]    ..........
			//  : [X][X][X] :    : [X][X]    : [X][X] :
			// [1][X][X][X][2]  [1][X][X]   [1][X][X] :
			//                              [X][X][X][2]
	        if (!solved) {
	        	//console.log("Case A");
	        	init();

				// While we haven't reached the top of the board
				while (cordY > 1 && solved !== true) {
					cordY--;// Move up 1 row
					//console.log("moved up to:("+cordX+","+cordY+")");
					// Get the new cell that we moved to.
					cell = $('#'+app.getId(cordX,cordY));
					// If the cell just moved up to is empty
					if (cell.data().solved === true || cell.data().solved === undefined){
						// While we haven't reached the same columm
						while(cordX < second.x) {
							cordX++; // Move right 1 column
							//console.log("moved right to:("+cordX+","+cordY+")");
							cell = $('#'+app.getId(cordX,cordY));
							// If we have moved up and right to the location
							if(cordY === second.y && cordX === second.x) {
								//console.log("MATCH!!!! via Case A");
								solved = true;
								break;
							}
							// If the column we just moved to is not occupied
							if(cell.data().solved === true || cell.data().solved === undefined){
								// If reached same column, iterate down.
								if(cordX === second.x){
									// When we iterate down we change cordY, cache it to prevent infinite loop
									tempY = cordY;
									// While we haven't moved down far enough
									while (cordY < second.y){
										cordY++; // Move down
										//console.log("moved down to:("+cordX+","+cordY+")");
										cell = $('#'+app.getId(cordX,cordY));
										// If we reached the same x and y position, solved
										if(cordY === second.y) {
											//console.log("MATCH!!!! via Case A");
											solved = true;
											break;
										}
										// Else if cell we just went to is occupied, break
										else if (cell.data().solved === false){
											//console.log("no match;");
											break;
										}
									}// Third while
									// Reset to same cordY before going right and down.
									cordY = tempY;
								}	
							}
							// Else column moved to the right is occupied
							else
								break;
							
						}// 2nd while
						// Reset cordX since iterated to new cordY
						cordX = first.x;
					}
					// Else the cell above is occupied, break
					else
						break;
				}// First while
			}// ---- CASE A ----

			// *********    CASE B    **********   
			//
			//	[1][X][X]     [1][X][X]   [X][X][2]
			//	 : [X][X][2]   : [X][X]   [1][X] :
			//	 : [X][X] :    : [X][X]	   : [X] :
			//   :........:    :... [2]    :.....:              
			if (!solved){
				//console.log("Case B");
				init();


				// While we haven't reached the bottom of the board
				while (cordY < 12 && solved !== true) {
					cordY++;// Move down 1 row
					//console.log("moved down to:("+cordX+","+cordY+")");
					// Get the new cell that we moved to.
					cell = $('#'+app.getId(cordX,cordY));
					// If the cell just moved down to is empty
					if (cell.data().solved === true || cell.data().solved === undefined){
						// While we haven't reached the same column
						while(cordX < second.x) {
							cordX++; //move right  M column
							//console.log("moved right to:("+cordX+","+cordY+")");
							cell = $('#'+app.getId(cordX,cordY));
							//if we have moved down and right to the location
							if(cordY === second.y && cordX === second.x) {
								//console.log("MATCH!!!! via Case B");
								solved = true;
								break;
							}
							// If the column we just moved to is not occupied
							if(cell.data().solved === true || cell.data().solved === undefined){
								// If reached same column, iterate up.
								if(cordX === second.x){
									// When we iterate up we change cordY, cache it to prevent infinite loop
									tempY = cordY;
									// While we haven't moved up far enough
									while (cordY > second.y){
										cordY--; // Move up
										//console.log("moved up to:("+cordX+","+cordY+")");
										cell = $('#'+app.getId(cordX,cordY));
										// If we reached the same x and y position, solved
										if(cordY === second.y) {
											//console.log("MATCH!!!! via Case B");
											solved = true;
											break;
										}
										// Else if cell we just went to is occupied, break
										else if (cell.data().solved === false){
											//console.log("no match;");
											break;
										}
									}// Third while
									// Reset to same cordY before going right and up.
									cordY = tempY;
								}	
							}
							// Else column moved to the right is occupied
							else
								break;
							
						}// 2nd while
						// Reset cordX since iterated to new cordY
						cordX = first.x;
					}
					// Else the cell above is occupied, break
					else
						break;
				}// First while	

			}// ---- CASE B ----

		}// CASE A & B

		
		// CASE C & D
		if (first.y > second.y){
			//console.log("hit case C & D");

			// *********    CASE C    ********** 
			//
			//   [2].......  [X][X][2]
			// 	 [X][X][X]:  [X][X] :
			//	 [X][1]...:  [1]....:
			if(!solved) {
				//console.log("Case C");
				init();

				// While we haven't reached the far right of the board
				while (cordX < 12 && solved !== true) {
					cordX++;// Move right 1 column
					//console.log("moved right to:("+cordX+","+cordY+")");
					// Get the new cell that we moved to.
					cell = $('#'+app.getId(cordX,cordY));
					// If the cell just moved right to is empty
					if (cell.data().solved === true || cell.data().solved === undefined){
						// While we haven't reached the same row
						while(cordY > second.y) {
							cordY--; // Move up 1 row
							//console.log("moved up to:("+cordX+","+cordY+")");
							cell = $('#'+app.getId(cordX,cordY));
							// If we have moved right and up to the location
							if(cordY === second.y && cordX === second.x) {
								//console.log("MATCH!!!! via Case E");
								solved = true;
								break;
							}
							// If the row we just moved to is not occupied
							if(cell.data().solved === true || cell.data().solved === undefined){
								// If reached same row, iterate left
								if(cordY === second.y){
									// When we iterate left we change cordX, cache it to prevent infinite loop
									tempX = cordX;
									// While we haven't moved left far enough
									while (cordX > second.x){
										cordX--; // Move left
										//console.log("moved left to:("+cordX+","+cordY+")");
										cell = $('#'+app.getId(cordX,cordY));
										// If we reached the same x and y position, solved
										if(cordX === second.x) {
											//console.log("MATCH!!!! via Case C");
											solved = true;
											break;
										}
										// Else if cell we just went to is occupied, break
										else if (cell.data().solved === false){
											//console.log("no match via C");
											break;
										}

									}// Third while
									// Reset to same cordY before going up and left
									cordX = tempX;
								}
							}
							// Else row moved up to is occupied
							else
								break;

						}// 2nd while
						// Reset cordX since iterated to new cordY
						cordY = first.y;
					}
					// Else the cell to left is occupied, break
					else
						break;
				}// 1st while
			}// ---- CASE C -----


			// *********    CASE D    ********** 
			//
			//   .......[2]  [2][X][X]
			// 	 :[X][X][X]   :[X][X]
			//	 :......[1]   :...[1]

			if(!solved) {
				//console.log("Case D");
				init();

				// While we haven't reached the far left of the board
				while (cordX > 1 && solved !== true) {
					cordX--;// Move left 1 column
					//console.log("moved left to:("+cordX+","+cordY+")");
					// Get the new cell that we moved to.
					cell = $('#'+app.getId(cordX,cordY));
					// If the cell just moved left to is empty
					if (cell.data().solved === true || cell.data().solved === undefined){
						// While we haven't reached the same row
						while(cordY > second.y) {
							cordY--; // Move up 1 row
							//console.log("moved up to:("+cordX+","+cordY+")");
							cell = $('#'+app.getId(cordX,cordY));
							// If we have moved left and up to the location
							if(cordY === second.y && cordX === second.x) {
								//console.log("MATCH!!!! via Case E");
								solved = true;
								break;
							}
							// If the row we just moved to is not occupied
							if(cell.data().solved === true || cell.data().solved === undefined){
								// If reached same row, iterate right
								if(cordY === second.y){
									// When we iterate right we change cordX, cache it to prevent infinite loop
									tempX = cordX;
									// While we haven't moved right far enough
									while (cordX < second.x){
										cordX++; // Move right
										//console.log("moved right to:("+cordX+","+cordY+")");
										cell = $('#'+app.getId(cordX,cordY));
										// If we reached the same x and y position, solved
										if(cordX === second.x) {
											//console.log("MATCH!!!! via Case D");
											solved = true;
											break;
										}
										// Else if cell we just went to is occupied, break
										else if (cell.data().solved === false){
											//console.log("no match via D");
											break;
										}
									}// Third while
									// Reset to same cordY before going up and right
									cordX = tempX;
								}
							}
							// Else row moved up to is occupied
							else
								break;

						}// 2nd while
						// Reset cordX since iterated to new cordY
						cordY = first.y;
					}
					// Else the cell to left is occupied, break
					else
						break;
				}// 1st while
			}// ---- CASE D -----


		} // CASE C & D


		// CASE E & F
		if (first.x > second.x){
			//console.log("hit case E & F");
			

			// *********    CASE E    **********   
			//
			//  ............. 	[2].....    ..........
			//  : [X][X][X] :   [X][X] :    : [X][X] :
			// [2][X][X][X][1]  [X][X][1]   [2][X][X] :
			//                              [X][X][X][1]
	        if (!solved) {
	        	//console.log("Case E");
	        	init();

				//while we haven't reached the top of the board
				while (cordY > 1 && solved !== true) {
					cordY--;//move up  M row
					//console.log("moved up to:("+cordX+","+cordY+")");
					// Get the new cell that we moved to.
					cell = $('#'+app.getId(cordX,cordY));
					//if the cell just moved up to is empty
					if (cell.data().solved === true || cell.data().solved === undefined){
						// While we haven't reached the same column
						while(cordX > second.x) {
							cordX--; //move left  M column
							//console.log("moved left to:("+cordX+","+cordY+")");
							cell = $('#'+app.getId(cordX,cordY));
							//if we have moved up and left to the location
							if(cordY === second.y && cordX === second.x) {
								//console.log("MATCH!!!! via Case E");
								solved = true;
								break;
							}
							// If the column we just moved to is not occupied
							if(cell.data().solved === true || cell.data().solved === undefined){
								//if reached same column, iterate down.
								if(cordX === second.x){
									//when we iterate down we change cordY, cache it to prevent infinite loop
									tempY = cordY;
									//while we haven't moved down far enough
									while (cordY < second.y){
										cordY++; // Move down
										//console.log("moved down to:("+cordX+","+cordY+")");
										cell = $('#'+app.getId(cordX,cordY));
										// If we reached the same x and y position, solved
										if(cordY === second.y) {
											//console.log("MATCH!!!! via Case E");
											solved = true;
											break;
										}
										// Else if cell we just went to is occupied, break
										else if (cell.data().solved === false){
											//console.log("no match;");
											break;
										}
									}// Third while
									// Reset to same cordY before going left and down.
									cordY = tempY;
								}	
							}
							// Else column moved to the left is occupied
							else
								break;
							
						}// 2nd while
						// Reset cordX since iterated to new cordY
						cordX = first.x;
					}
					// Else the cell above is occupied, break
					else
						break;
				}// First while
			}// ---- CASE E ----

			// *********    CASE F    **********   
			//
			//	[1][X][X]     [1][X][X]   [X][X][2]
			//	 : [X][X][2]   : [X][X]   [1][X] :
			//	 : [X][X] :    : [X][X]	   : [X] :
			//   :........:    :... [2]    :.....: 
			if (!solved){
				//console.log("Case B");
				init();


				// While we haven't reached the bottom of the board
				while (cordY < 12 && solved !== true) {
					cordY++;// Move down 1 row
					//console.log("moved down to:("+cordX+","+cordY+")");
					// Get the new cell that we moved to.
					cell = $('#'+app.getId(cordX,cordY));
					// If the cell just moved down to is empty
					if (cell.data().solved === true || cell.data().solved === undefined){
						// While we haven't reached the same column
						while(cordX > second.x) {
							cordX--; //move left  M column
							//console.log("moved left to:("+cordX+","+cordY+")");
							cell = $('#'+app.getId(cordX,cordY));
							//if we have moved down and left to the location
							if(cordY === second.y && cordX === second.x) {
								//console.log("MATCH!!!! via Case F");
								solved = true;
								break;
							}
							// If the column we just moved to is not occupied
							if(cell.data().solved === true || cell.data().solved === undefined){
								// If reached same column, iterate up.
								if(cordX === second.x){
									// When we iterate up we change cordY, cache it to prevent infinite loop
									tempY = cordY;
									// While we haven't moved up far enough
									while (cordY > second.y){
										cordY--; // Move up
										//console.log("moved up to:("+cordX+","+cordY+")");
										cell = $('#'+app.getId(cordX,cordY));
										// If we reached the same x and y position, solved
										if(cordY === second.y) {
											//console.log("MATCH!!!! via Case F");
											solved = true;
											break;
										}
										// Else if cell we just went to is occupied, break
										else if (cell.data().solved === false){
											//console.log("no match;");
											break;
										}
									}// Third while
									// Reset to same cordY before going left and up.
									cordY = tempY;
								}	
							}
							// Else column moved to the left is occupied
							else
								break;
							
						}// 2nd while
						// Reset cordX since iterated to new cordY
						cordX = first.x;
					}
					// Else the cell above is occupied, break
					else
						break;
				}// First while	

			}// ---- CASE F ----


		}// CASE E & F

		// CASE G & H
		if (first.y < second.y){
			//console.log("hit case G & H");

			// *********    CASE G    ********** 
			//
			//   [1].......  [1].....
			// 	 [X][X][X]:  [X][X] :
			//	 [X][2]...:  [X][X][2]
			if(!solved) {
				//console.log("Case G");
				init();

				// While we haven't reached the far right of the board
				while (cordX < 12 && solved !== true) {
					cordX++;// Move right 1 column
					//console.log("moved right to:("+cordX+","+cordY+")");
					// Get the new cell that we moved to.
					cell = $('#'+app.getId(cordX,cordY));
					// If the cell just moved right to is empty
					if (cell.data().solved === true || cell.data().solved === undefined){
						// While we haven't reached the same row
						while(cordY < second.y) {
							cordY++; // Move down 1 row
							//console.log("moved down to:("+cordX+","+cordY+")");
							cell = $('#'+app.getId(cordX,cordY));
							// If we have moved right and down to the location
							if(cordY === second.y && cordX === second.x) {
								//console.log("MATCH!!!! via Case G");
								solved = true;
								break;
							}
							// If the row we just moved to is not occupied
							if(cell.data().solved === true || cell.data().solved === undefined){
								// If reached same row, iterate left
								if(cordY === second.y){
									// When we iterate left we change cordX, cache it to prevent infinite loop
									tempX = cordX;
									// While we haven't moved left far enough
									while (cordX > second.x){
										cordX--; // Move left
										//console.log("moved left to:("+cordX+","+cordY+")");
										cell = $('#'+app.getId(cordX,cordY));
										// If we reached the same x and y position, solved
										if(cordX === second.x) {
											//console.log("MATCH!!!! via Case G");
											solved = true;
											break;
										}
										// Else if cell we just went to is occupied, break
										else if (cell.data().solved === false){
											//console.log("no match via G");
											break;
										}

									}// Third while
									// Reset to same cordY before going down and left
									cordX = tempX;
								}
							}
							// Else row moved down to is occupied
							else
								break;

						}// 2nd while
						// Reset cordX since iterated to new cordY
						cordY = first.y;
					}
					// Else the cell to left is occupied, break
					else
						break;
				}// 1st while
			}// ---- CASE G -----

			// *********    CASE H    ********** 
			//
			//   .......[1]   ....[1]
			// 	 :[X][X][X]   :[X][X]
			//	 :......[2]  [2]

			if(!solved) {
				//console.log("Case H");
				init();

				// While we haven't reached the far left of the board
				while (cordX > 1 && solved !== true) {
					cordX--;// Move left 1 column
					//console.log("moved left to:("+cordX+","+cordY+")");
					// Get the new cell that we moved to.
					cell = $('#'+app.getId(cordX,cordY));
					// If the cell just moved left to is empty
					if (cell.data().solved === true || cell.data().solved === undefined){
						// While we haven't reached the same row
						while(cordY < second.y) {
							cordY++; // Move down 1 row
							//console.log("moved down to:("+cordX+","+cordY+")");
							cell = $('#'+app.getId(cordX,cordY));
							// If we have moved left and down to the location
							if(cordY === second.y && cordX === second.x) {
								//console.log("MATCH!!!! via Case H");
								solved = true;
								break;
							}
							// If the row we just moved to is not occupied
							if(cell.data().solved === true || cell.data().solved === undefined){
								// If reached same row, iterate right
								if(cordY === second.y){
									// When we iterate right we change cordX, cache it to prevent infinite loop
									tempX = cordX;
									// While we haven't moved right far enough
									while (cordX < second.x){
										cordX++; // Move right
										//console.log("moved right to:("+cordX+","+cordY+")");
										cell = $('#'+app.getId(cordX,cordY));
										// If we reached the same x and y position, solved
										if(cordX === second.x) {
											//console.log("MATCH!!!! via Case H");
											solved = true;
											break;
										}
										// Else if cell we just went to is occupied, break
										else if (cell.data().solved === false){
											//console.log("no match via H");
											break;
										}
									}// Third while
									// Reset to same cordY before going up and right
									cordX = tempX;
								}
							}
							// Else row moved up to is occupied
							else
								break;

						}// 2nd while
						// Reset cordX since iterated to new cordY
						cordY = first.y;
					}
					// Else the cell to left is occupied, break
					else
						break;
				}// 1st while
			}// ---- CASE D -----



		}// Case G & H

		//final
		if (solved) {
			app.matchSuccess(first,second);
			return true;
		}
		else
			return false;

	}//case2
};;//--------------------
// Test if a Zig-Zag pattern has occurred
var case3 = {

	//Zig Zagz Algorithm
	test: function(first,second) {
		var cordX = first.x, cordY = first.y, tempX, tempY, solved = false, cell;
		//console.log("---------------------------------");
		
		//--------------------
		// initialize algorithm
		function init() {
			cordX = first.x; 
			cordY = first.y;
			solved = false;
		}
		
		// Case I & J
		if (first.x < second.x){
			//console.log("Entered Case I & J");

			// Case I
			//		  .....[2]
			//        :
			// [1]....:

			if (!solved){
				//console.log("Case I");
				init();

				// While we reached the same column 
				while (cordX < second.x && !solved) {
					cordX++; // Go right one column
					//console.log("moved right to:("+cordX+","+cordY+")");
					// Get the new cell that we moved to.
					cell = $('#'+app.getId(cordX,cordY));
					// If the cell just moved right to is empty
					if (cell.data().solved === true || cell.data().solved === undefined){
						// While we haven't reached the same row
						while (cordY > second.y) {
							cordY--; // Go up one row
							//console.log("moved up to:("+cordX+","+cordY+")");
							cell = $('#'+app.getId(cordX,cordY));
							// If we have moved right and up to the location
							if (cordY === second.y && cordX === second.x) {
								//console.log("Match! via Case I");
								solved = true;
								break;
							}
							// If the row we just moved up to is empty
							if (cell.data().solved === true || cell.data().solved === undefined) {
								// If we reached same row
								if (cordY === second.y) {
									// When we iterate across we change cordX, cache it to prevent havoc
									tempX = cordX;
									// While we haven't moved far enough right
									while (cordX < second.x) {
										cordX++; // Move right
										//console.log("moved right to:("+cordX+","+cordY+")");
										cell = $('#'+app.getId(cordX,cordY));
										// If we reached the same x and y position, solved
										if (cordX === second.x && cordY === second.y) {
											//console.log("Match! via Case I");
											solved = true;
											break;
										}
										// Else if cell we just went to is occupied, break
										else if (cell.data().solved === false){
											//console.log("no match via I");
											break;
										}
									}// Third while
									// Reset to same cordX before going right and up
									cordX = tempX;				
								}
							}
							// Else row moved up to is occupied
							else
								break;
						}// 2nd while
						// Reset y cord after iterating up and right
						cordY = first.y;
					}
					// Else the cell to the right is occupied
					else
						break;

				}// first while

			}


			// Case J
			// [1].....
			//        :
			//        :....[2]

			if (!solved){
				//console.log("Case J");
				init();

				// While we reached the same column 
				while (cordX < second.x && !solved) {
					cordX++; // Go right one column
					//console.log("moved right to:("+cordX+","+cordY+")");
					// Get the new cell that we moved to.
					cell = $('#'+app.getId(cordX,cordY));
					// If the cell just moved right to is empty
					if (cell.data().solved === true || cell.data().solved === undefined){
						// While we haven't reached the same row
						while (cordY < second.y) {
							cordY++; // Go down one row
							//console.log("moved down to:("+cordX+","+cordY+")");
							cell = $('#'+app.getId(cordX,cordY));
							// If we have moved right and down to the location
							if (cordY === second.y && cordX === second.x) {
								//console.log("Match! via Case J");
								solved = true;
								break;
							}
							// If the row we just moved down to is empty
							if (cell.data().solved === true || cell.data().solved === undefined) {
								// If we reached same row
								if (cordY === second.y) {
									// When we iterate across we change cordX, cache it to prevent havoc
									tempX = cordX;
									// While we haven't moved far enough right
									while (cordX < second.x) {
										cordX++; // Move right
										//console.log("moved right to:("+cordX+","+cordY+")");
										cell = $('#'+app.getId(cordX,cordY));
										// If we reached the same x and y position, solved
										if (cordX === second.x && cordY === second.y) {
											//console.log("Match! via Case J");
											solved = true;
											break;
										}
										// Else if cell we just went to is occupied, break
										else if (cell.data().solved === false){
											//console.log("no match via J");
											break;
										}
									}// Third while
									// Reset to same cordX before going right and down
									cordX = tempX;				
								}
							}
							// Else row moved down to is occupied
							else
								break;
						}// 2nd while
						// Reset y cord after iterating down and right
						cordY = first.y;
					}
					// Else the cell to the right is occupied
					else
						break;

				}// first while

			}
		}// Case I & J

		// Case K & L
		if (first.y > second.y){


			// Case K
			// 	   [2]
			//  ....:
			//	:
			// [1]
			if(!solved){
				//console.log("Case K");
				init();

				// While we reached the same row 
				while (cordY > second.y && !solved) {
					cordY--; // Go up one row
					//console.log("moved up to:("+cordX+","+cordY+")");
					// Get the new cell that we moved to.
					cell = $('#'+app.getId(cordX,cordY));
					// If the cell just moved up to is empty
					if (cell.data().solved === true || cell.data().solved === undefined){
						// While we haven't reached the same column
						while (cordX < second.x) {
							cordX++; // Go right one column
							//console.log("moved right to:("+cordX+","+cordY+")");
							cell = $('#'+app.getId(cordX,cordY));
							// If we have moved up and right to the location
							if (cordY === second.y && cordX === second.x) {
								//console.log("Match! via Case K");
								solved = true;
								break;
							}
							// If the column we just moved down to is empty
							if (cell.data().solved === true || cell.data().solved === undefined) {
								// If we reached same row
								if (cordX === second.x) {
									// When we iterate across we change cordY, cache it to prevent havoc
									tempY = cordY;
									// While we haven't moved far enough up
									while (cordY > second.y) {
										cordY--; // Move up
										//console.log("moved up to:("+cordX+","+cordY+")");
										cell = $('#'+app.getId(cordX,cordY));
										// If we reached the same x and y position, solved
										if (cordX === second.x && cordY === second.y) {
											//console.log("Match! via Case K");
											solved = true;
											break;
										}
										// Else if cell we just went to is occupied, break
										else if (cell.data().solved === false){
											//console.log("no match via K");
											break;
										}
									}// Third while
									// Reset to same cordY before going up and right
									cordY = tempY;				
								}
							}
							// Else row moved down to is occupied
							else
								break;
						}// 2nd while
						// Reset x cord after iterating right and up
						cordX = first.x;
					}
					// Else the cell up is occupied
					else
						break;

				}// first while



			}

			// Case L
			// [2]
			//  :....
			//	    :
			// 	   [1]
			if(!solved){
				//console.log("Case L");
				init();

				// While we reached the same row 
				while (cordY > second.y && !solved) {
					cordY--; // Go up one row
					//console.log("moved up to:("+cordX+","+cordY+")");
					// Get the new cell that we moved to.
					cell = $('#'+app.getId(cordX,cordY));
					// If the cell just moved up to is empty
					if (cell.data().solved === true || cell.data().solved === undefined){
						// While we haven't reached the same column
						while (cordX > second.x) {
							cordX--; // Go left one column
							//console.log("moved left to:("+cordX+","+cordY+")");
							cell = $('#'+app.getId(cordX,cordY));
							// If we have moved up and left to the location
							if (cordY === second.y && cordX === second.x) {
								//console.log("Match! via Case L");
								solved = true;
								break;
							}
							// If the column we just moved down to is empty
							if (cell.data().solved === true || cell.data().solved === undefined) {
								// If we reached same row
								if (cordX === second.x) {
									// When we iterate across we change cordY, cache it to prevent havoc
									tempY = cordY;
									// While we haven't moved far enough up
									while (cordY > second.y) {
										cordY--; // Move up
										//console.log("moved up to:("+cordX+","+cordY+")");
										cell = $('#'+app.getId(cordX,cordY));
										// If we reached the same x and y position, solved
										if (cordX === second.x && cordY === second.y) {
											//console.log("Match! via Case L");
											solved = true;
											break;
										}
										// Else if cell we just went to is occupied, break
										else if (cell.data().solved === false){
											//console.log("no match via L");
											break;
										}
									}// Third while
									// Reset to same cordY before going up and left
									cordY = tempY;				
								}
							}
							// Else row moved down to is occupied
							else
								break;
						}// 2nd while
						// Reset x cord after iterating left and up
						cordX = first.x;
					}
					// Else the cell up is occupied
					else
						break;

				}// first while

			}
		}

		// Case M & N
		if (first.x > second.x){
			
			// Case M
			// [2].....
			//        :
			//        :....[1]
			if(!solved){
				//console.log("Case M");
				init();

				// While we reached the same column 
				while (cordX > second.x && !solved) {
					cordX--; // Go left one column
					//console.log("moved left to:("+cordX+","+cordY+")");
					// Get the new cell that we moved to.
					cell = $('#'+app.getId(cordX,cordY));
					// If the cell just moved left to is empty
					if (cell.data().solved === true || cell.data().solved === undefined){
						// While we haven't reached the same row
						while (cordY > second.y) {
							cordY--; // Go up one row
							//console.log("moved up to:("+cordX+","+cordY+")");
							cell = $('#'+app.getId(cordX,cordY));
							// If we have moved left and up to the location
							if (cordY === second.y && cordX === second.x) {
								//console.log("Match! via Case M");
								solved = true;
								break;
							}
							// If the row we just moved up to is empty
							if (cell.data().solved === true || cell.data().solved === undefined) {
								// If we reached same row
								if (cordY === second.y) {
									// When we iterate across we change cordX, cache it to prevent havoc
									tempX = cordX;
									// While we haven't moved far enough left
									while (cordX > second.x) {
										cordX--; // Move left
										//console.log("moved left to:("+cordX+","+cordY+")");
										cell = $('#'+app.getId(cordX,cordY));
										// If we reached the same x and y position, solved
										if (cordX === second.x && cordY === second.y) {
											//console.log("Match! via Case M");
											solved = true;
											break;
										}
										// Else if cell we just went to is occupied, break
										else if (cell.data().solved === false){
											//console.log("no match via M");
											break;
										}
									}// Third while
									// Reset to same cordX before going left and up
									cordX = tempX;				
								}
							}
							// Else row moved up to is occupied
							else
								break;
						}// 2nd while
						// Reset y cord after iterating up and left
						cordY = first.y;
					}
					// Else the cell to the left is occupied
					else
						break;

				}// first while


			}

			// Case N
			//		  .....[1]
			//        :
			// [2]....:
			if(!solved){
				//console.log("Case N");
				init();

				// While we reached the same column 
				while (cordX > second.x && !solved) {
					cordX--; // Go left one column
					//console.log("moved left to:("+cordX+","+cordY+")");
					// Get the new cell that we moved to.
					cell = $('#'+app.getId(cordX,cordY));
					// If the cell just moved left to is empty
					if (cell.data().solved === true || cell.data().solved === undefined){
						// While we haven't reached the same row
						while (cordY < second.y) {
							cordY++; // Go down one row
							//console.log("moved down to:("+cordX+","+cordY+")");
							cell = $('#'+app.getId(cordX,cordY));
							// If we have moved left and down to the location
							if (cordY === second.y && cordX === second.x) {
								//console.log("Match! via Case N");
								solved = true;
								break;
							}
							// If the row we just moved down to is empty
							if (cell.data().solved === true || cell.data().solved === undefined) {
								// If we reached same row
								if (cordY === second.y) {
									// When we iterate across we change cordX, cache it to prevent havoc
									tempX = cordX;
									// While we haven't moved far enough left
									while (cordX > second.x) {
										cordX--; // Move left
										//console.log("moved left to:("+cordX+","+cordY+")");
										cell = $('#'+app.getId(cordX,cordY));
										// If we reached the same x and y position, solved
										if (cordX === second.x && cordY === second.y) {
											//console.log("Match! via Case N");
											solved = true;
											break;
										}
										// Else if cell we just went to is occupied, break
										else if (cell.data().solved === false){
											//console.log("no match via N");
											break;
										}
									}// Third while
									// Reset to same cordX before going left and down
									cordX = tempX;				
								}
							}
							// Else row moved down to is occupied
							else
								break;
						}// 2nd while
						// Reset y cord after iterating down and left
						cordY = first.y;
					}
					// Else the cell to the left is occupied
					else
						break;

				}// first while

			}
		}

		// Case O & P
		if (first.y < second.y){

			//Case O
		    // [2]
			//  :....
			//	    :
			//     [1]

			if(!solved){
				//console.log("Case O");
				init();

				// While we reached the same row 
				while (cordY < second.y && !solved) {
					cordY++; // Go down one row
					//console.log("moved down to:("+cordX+","+cordY+")");
					// Get the new cell that we moved to.
					cell = $('#'+app.getId(cordX,cordY));
					// If the cell just moved down to is empty
					if (cell.data().solved === true || cell.data().solved === undefined){
						// While we haven't reached the same column
						while (cordX < second.x) {
							cordX++; // Go right one column
							//console.log("moved right to:("+cordX+","+cordY+")");
							cell = $('#'+app.getId(cordX,cordY));
							// If we have moved down and right to the location
							if (cordY === second.y && cordX === second.x) {
								//console.log("Match! via Case O");
								solved = true;
								break;
							}
							// If the column we just moved down to is empty
							if (cell.data().solved === true || cell.data().solved === undefined) {
								// If we reached same row
								if (cordX === second.x) {
									// When we iterate across we change cordY, cache it to prevent havoc
									tempY = cordY;
									// While we haven't moved far enough down
									while (cordY < second.y) {
										cordY++; // Move down
										//console.log("moved down to:("+cordX+","+cordY+")");
										cell = $('#'+app.getId(cordX,cordY));
										// If we reached the same x and y position, solved
										if (cordX === second.x && cordY === second.y) {
											//console.log("Match! via Case O");
											solved = true;
											break;
										}
										// Else if cell we just went to is occupied, break
										else if (cell.data().solved === false){
											//console.log("no match via O");
											break;
										}
									}// Third while
									// Reset to same cordY before going down and right
									cordY = tempY;				
								}
							}
							// Else row moved down to is occupied
							else
								break;
						}// 2nd while
						// Reset x cord after iterating right and down
						cordX = first.x;
					}
					// Else the cell down is occupied
					else
						break;

				}// first while



			}

			//Case P
			// 	   [1]
			//  ....:
			//	:
			// [2]

			if(!solved){
				//console.log("Case P");
				init();


				// While we reached the same row 
				while (cordY < second.y && !solved) {
					cordY++; // Go down one row
					//console.log("moved down to:("+cordX+","+cordY+")");
					// Get the new cell that we moved to.
					cell = $('#'+app.getId(cordX,cordY));
					// If the cell just moved down to is empty
					if (cell.data().solved === true || cell.data().solved === undefined){
						// While we haven't reached the same column
						while (cordX > second.x) {
							cordX--; // Go left one column
							//console.log("moved left to:("+cordX+","+cordY+")");
							cell = $('#'+app.getId(cordX,cordY));
							// If we have moved down and left to the location
							if (cordY === second.y && cordX === second.x) {
								//console.log("Match! via Case P");
								solved = true;
								break;
							}
							// If the column we just moved down to is empty
							if (cell.data().solved === true || cell.data().solved === undefined) {
								// If we reached same row
								if (cordX === second.x) {
									// When we iterate across we change cordY, cache it to prevent havoc
									tempY = cordY;
									// While we haven't moved far enough down
									while (cordY < second.y) {
										cordY++; // Move down
										//console.log("moved down to:("+cordX+","+cordY+")");
										cell = $('#'+app.getId(cordX,cordY));
										// If we reached the same x and y position, solved
										if (cordX === second.x && cordY === second.y) {
											//console.log("Match! via Case P");
											solved = true;
											break;
										}
										// Else if cell we just went to is occupied, break
										else if (cell.data().solved === false){
											//console.log("no match via P");
											break;
										}
									}// Third while
									// Reset to same cordY before going down and left
									cordY = tempY;				
								}
							}
							// Else row moved down to is occupied
							else
								break;
						}// 2nd while
						// Reset x cord after iterating left and down
						cordX = first.x;
					}
					// Else the cell down is occupied
					else
						break;

				}// first while

			}
		}


		//final
		if (solved) {
			app.matchSuccess(first,second);
			return true;
		}
		else
			return false;


	}//case3
};;var firebase = {



	init: function() {
		console.log("fb");
		firebase.db = new Firebase('https://cosella.firebaseio.com/highscores');

	},

	push: function(name, twitterHandle, level, score) {
		var twitterUrl = "https://twitter.com/" + twitterHandle;
		firebase.db.push({'name': name , 'twitter': twitterUrl, 'level': level, 'score': score});
	},

	getHighscores: function() {

	}

};;
var icons = [
	{
		id: 0,
		color: "darkblue",
		img: "Qbert"
	},
	{
		id: 1,
		color: "saddlebrown",
		img: "Hami"
	},
	{
		id: 2,
		color: "gold",
		img: "Chris"
	},
	{
		id: 3,
		color: "gray",
		img: "Rob"
	},
	{
		id: 4,
		color: "mediumaquamarine",
		img: "Simon"
	},
	{
		id: 5,
		color: "darkkhaki",
		img: "Owen"
	},
	{
		id: 6,
		color: "brown",
		img: "Mark-L"
	},
	{
		id: 7,
		color: "peru",
		img: "Steven"
	},
	{
		id: 8,
		color: "deeppink",
		img: "Brian"
	},
	{
		id: 9,
		color: "cyan",
		img: "Raymond"
	},
	{
		id: 10,
		color: "lightcoral",
		img: "Hannah"
	},
	{
		id: 11,
		color: "steelblue",
		img: "Adam"
	},
	{
		id: 12,
		color: "darkviolet",
		img: "Jenn"
	},
	{
		id: 13,
		color: "limegreen",
		img: "Rebecca"
	},
	{
		id: 14,
		color: "whitesmoke",
		img: "Hema"
	}

];
;
/*	Global Variables
 *	app.totCells     - Int Total # of cells on board
 *  app.currentLevel - Int Current level (1 - 4)
 *  app.totSolved    - Int Total # of solved Icons for current level
 *  app.totIcons     - Int Total # of Icons on board for current level
 *  app.first        - Object containing Data of first cell selected
 *  app.second       - Object containing Data of second cell selected
 *  app.score		 - Int Score in game
 *  app.gamePaused   - Boolean is the game paused.
 *	app.count        - Int time remaining in game
 *  app.timeLimit	 - Int total time in milliseconds allowed per level
 *  app.start        - Int starting id location on grid for current level
 *  app.rows         - Int # of rows for current level
 *  app.columns      - Int # of columns for current level
 */

//--------------------
// App - Main variable holding functions & variables for the game
var app = {

	//--------------------
	// init - Initializes the environment for the game
	init: function(){
	
		// 100 seconds per level
		//--------------------
		app.timeLimit = 100000;
		
		// Initialize Timer counter
		//--------------------
		app.count = app.timeLimit;
		$('#countdown').html(formatTime(app.count));
		// Initialize timer
		timer.set({ time : 10, autostart : false });

		// Initialize score
		//--------------------
		app.score = 0; 	
		$('.totscore').html(app.score);

		app.gamePaused = false;	
		app.totCells = 144;

		// Start at level 1
		app.currentLevel = 1;
		var gamegrid = $('#gamegrid');

		// Build HTML used to append cells to grid
		//--------------------
		var cellStart = '<div class=cell data-id="null" style="background-color: rgba(237,236,236,1)" id=';
		var cellEnd = "></div>";
		var cellHTML = '';

		// Append all the cells to the DOM
		for (var i = 1; i < app.totCells+1; i++) {
			cellHTML =  cellStart+i+cellEnd;
			gamegrid.append(cellHTML);
			cellHTML = cellStart;
		}

		// Array to keep track of which Octocats have been used
		app.octocatTracker = Array();


		// Generate Icons & draw to board
		app.buildIcons(app.currentLevel);
	},

	// Event Listeners
	//--------------------
	eventListeners: function(){
		
		var select = false; // Have we selected one already?

		// Clicking on a cell
		//--------------------
		$('.cell').on('click', function(event){
				
			event.preventDefault();
			var selectedCell = $(this);
			var selectedCellData = selectedCell.data();

			// If we clicked on a selectable cell
			// Data-id null if solved or empty
			if(selectedCellData.id !== null){
				// Make sure timer is running
				if (!timer.isActive){
					timer.play(true);
				}
				// If first click
				if (select === false){
					select = true;
					selectedCell.addClass("selected");
					app.first = selectedCellData;
				} 
				// 2nd click
				else { 
					// Make sure not selecting same cell
					if (app.getId( selectedCellData.x,selectedCellData.y) === app.getId( app.first.x, app.first.y) ){
						// If selected same class, removed selected, reset to 1st click
						selectedCell.removeClass('selected');
						select = false;
					}
					else{
						// Reset clicks and check if its a Match
						select = false;
						app.second = selectedCellData;
						app.checkMatch();
					}
				}
			}
		});

		// Modal functionality
		//--------------------
		function closeModal() {
			// If game was paused, resume clock! no cheating
			if (app.gamePaused === true){
				timer.play();
			}
			$(".overlay").fadeOut();
		}

		// Quickly close modal
		$(".overlay").on("click", function(){
			// Only class with close is Instructions
			if ($(this).hasClass("close")) {
				closeModal();
			}
		});

		// Next level
		$('#nextLvl').on('click', function(){
			$('#nextLevel').fadeOut();
			app.buildIcons(app.currentLevel);
		});

		// Game Over
		$('#playAgain').on('click', function(){
			app.restartGame();
		});

		// Footer buttons
		//--------------------
		$('#moreTime').on("click", function(){
			app.count += 10000;
		});

		$("#instruct").on("click", function(){
			app.instructions();
		});

		$('#reOrder').on("click", function(){
			app.reOrder(app.rows,app.columns,app.start);
		});



	},// eventListeners

	//--------------------
	// buildIcons - function that evenly generates all icons and draws to grid
	// @param level - int representing which level in game 
	buildIcons: function(level){

		app.totSolved = 0;  // Reset # of solved icons

		var distribution,   // Array representing # of times each icon has been Drawn
		    totDistributed, // Int keeps track of total number of icons drawn
		    totalOutput,    // Int Total # of icons to be outputed
		    rows, columns,  // Int rows & columns on grid
		    icon,           // Object retrieved from icons.js containing id and color/background
		    odd,            // Boolean determining if found any odd icons
		    start,          // Starting location of where to start drawing icons
		    selector,       // String representing # for jQuery calls
		    sum;            // Int that determines which id on board to target

		//--------------------
		// Init - Initialize build depending which level game is on
		// @param level - which level game is on
		function init(level){

			distribution = new Array(icons.length);
			for (var k = 0; k < icons.length; k++) {
				distribution[k] = 0;
			}

			switch(level) {
				case 1: 
					start = 40;
					rows = 6;
					columns = 6;
					break;
				case 2:
					start = 27;
					rows = 8;
					columns = 8;
					break;
				case 3:
					start = 26;
					rows = 8;
					columns = 10;
					break;
				case 4:
					start = 14;
					rows = 10;
					columns = 10;
					break;
			}

			totalOutput =  rows * columns;
			app.totIcons = totalOutput; // Total # of icons to be solved
			totDistributed = 0; // Reset total icons distributed to grid
			selector = '#';
			// Assign globaly for re-Order
			app.start = start;
			app.rows = rows;
			app.columns = columns; 
		}

		init(level);

		// Iterate through all cells on current level
		for (var i = 0; i < columns; i++) {
			for(var j = 0; j < rows; j++){
				// calculate which id on grid
				sum = start + i + j*12; 
				var sel = $(selector+sum); 
				
				// Ensure everything has a match when close to limit
				if (totalOutput - totDistributed <= icons.length){

					odd = false; // Test if found odd # of a distributed icon
					
					// Iterate through distribution and test to see what is odd
					for (var k = 0; k < distribution.length; k++){

						// If odd number distributed, get that icon to even out
						if (distribution[k] % 2 === 1 ){
							icon = icons[k];
							
							odd = true;
							break;
						}
					}
					// Else all icons are evenly distributed
					if (odd === false){
						// Get random icon
						icon = app.getIcon();						
					}
				}

				else 
					icon = app.getIcon();

				// Increase tot distributed for that particular Icon
				distribution[icon.id]++; 
				// Increase total icons distributed
				totDistributed++;
				
				// Change from Color to Background-Image
				//--------------------
				//var color = icon.color;
				//sel.css('background-color',color);
				//sel.data('id',color);

				var img = "url(images/icons/" + icon.img+".png)";
				sel.css('background-image',img);

				// Assign data attributes to DOM
				sel.data('id',icon.img);
				sel.data('solved',false);
				sel.data('x',app.getX(sum));
				sel.data('y',app.getY(sum));

			}	
		}

		// We have even distribution but last 4-12 cells are repeats side by side
		// Re order so its more random
		app.reOrder(rows, columns, start);

	}, // BuildIcons

	//--------------------
	// Randomly select an Icon
	// @return Object - Icon from Icons.js
	getIcon: function() {
		var rand = Math.floor((Math.random() * (icons.length)));
		return icons[rand];
	},

	//--------------------
	// Randomly select an Octocat for next level
	// @return String - filename of an Octocat
	getOctocat: function() {
		var rand = Math.floor((Math.random() * (octocats.length)));
		
		// Ensure that we are getting an octocat that hasn't already been used
		if (!app.octocatTracker.contains(rand)){
			app.octocatTracker.push(rand);
			return octocats[rand].img;
		}
		// If it has been used then try again!
		else
			return app.getOctocat();
	},

	//--------------------
	// If id % 12 = 0 then on 12th column, return 12, else return id % 12
	// @param id - represents an position on the grid from 1-144
	// @return int - An x coordinate representing which column the icon is on 
	getX: function(id) {
		return (id % 12 === 0) ? 12 : id % 12; 
	},

	//--------------------
	// Return which row cell falls on based on 12 cells in a row
	// @param id - represents an position on the grid from 1-144
	// @return int - An y coordinate representing which row the icon is on
	getY: function(id) {
		return Math.ceil(id/12);
	},

	//--------------------
	// Get a cell's id based on x & y coordinates
	// @param x - int represent x coordinate on grid
	// @param y - int represent y coordinate on grid
	// @return int - representing id on grid (1-144)
	getId: function(x,y){
		// Y ordering starts at 1, account for this
		return(x + 12 * (y-1));
	},

	//--------------------
	// Increase score after match
	increaseScore: function(){
		// Each match increases score by 10
		app.score += 10;
		$('.totscore').html(app.score);
	},

	//--------------------
	// Check if two cell's selected match each other
	checkMatch: function(){

		// Remove selected Animation
		$('.cell').removeClass('selected');
		
		// If they are both the same icon
		if (case0.test(app.first,app.second) === true){
			// If they are both on same X or Y axis
			if (case1.test(app.first,app.second) === false)
				// If they can be matched through U or L shaped paths
				if(case2.test(app.first,app.second) === false)
					// Attempt to match through Zig-Zag pattern
					case3.test(app.first,app.second);
		}
		//else 
		//	console.log("Try to select the same Icon"); // Not same Icon
	},

	//--------------------
	// Successfully matched two cells, update their data fields & remove BG
	// @param first - Obj containing the first selected cell's data object
	// @param second - Obj containing the second selected cell's data object
	matchSuccess: function(first,second) {
		cell1 =  $('#'+app.getId(first.x,first.y));
		cell2 =  $('#'+app.getId(second.x,second.y));

		cell1.data('solved',true);
		cell1.data('id',null);
		cell2.data('solved',true);
		cell2.data('id',null);
		cell1.css('background-color','rgba(237,236,236,1)');
		cell2.css('background-color','rgba(237,236,236,1)');
		cell1.css('background-image', 'none');
		cell2.css('background-image', 'none');


		// Just matched two squares.
		app.totSolved = app.totSolved + 2;

		app.increaseScore();

		app.testLevelCompletion();

	},


	//--------------------
	// Test if we've matched all the icons for the level
	// Increment level if so
	testLevelCompletion: function() {

		if (app.totSolved === app.totIcons) {
			timer.stop();
			app.count = app.timeLimit;
			$('#countdown').html(formatTime(app.count));
			//console.log("win");
			// if you beat level 4 keep playing it
			if (app.currentLevel !== 4 )
				app.currentLevel++;

			app.nextLevel();
			
		}
	},


	//--------------------
	// Display Next Level modal with a new Octocat
	nextLevel: function() {
		$('#nextLevel').fadeIn();
		var image = 'images/octocats/' + app.getOctocat();
		
		$('#octocat').attr('src',image);
	},


	//--------------------
	// ReOrder all the icons currently displayed on grid
	// Ensure all solved positions are not redrawn to
	// @param rows - int # of rows for current level
	// @param columns - int # of columns for current level
	// @param start - int id position on grid from where we draw from
	reOrder: function(rows,columns,start) {
		
		// Which id's are unsolved?
		var idsUsed = Array();
		
		// Which icons have we used? 
		var iconsUsed = Array();
		
		// Out of the icons we have used, which have we reOrdered?
		var iconsDistributed = Array();
		
		// Sum refers to calculated id
		var sum, selector = '#';

		//--------------------
		// Get an index representing an icon that hasn't been distributed
		function randomNumber() {
			var rand = Math.floor((Math.random() * (iconsUsed.length)));

			// make sure the number hasn't been already distributed
			if (!iconsDistributed.contains(rand)){
				iconsDistributed.push(rand);
				return rand;
			}
			else // Else try again
				return randomNumber(length);
		}

		// Iterate through all cells and find all unsolved cells
		for (var i = 0; i < columns; i++) {
			for(var j = 0; j < rows; j++){
				sum = start + i + j*12; //id on grid
				var sel = $(selector+sum);

				// If the square has not been solved
				if (sel.data().id !== null){
					// Add id & Icon to arrays 
					
					idsUsed.push(sum);
					iconsUsed.push(sel.data().id);
				}
			}
		}

		// Iterate through all unsolved Cells
		for (var k = 0; k < idsUsed.length; k++){
			
		 	var select = $(selector+idsUsed[k]);

		 	// get and Icon that hasn't been distributed yet
		 	var icon = randomNumber();
		 	//console.log(idsUsed[k] + " col: " + iconsUsed[color]);
		 	select.data('id',iconsUsed[icon]);
		 	//select.css('background-icon', iconsUsed[icon]);
		 	var img = "url(images/icons/" + iconsUsed[icon]+".png)";
		 	select.css('background-image', img);

		}

	},

	//--------------------
	// Display instructions Modal and pause the game
	instructions: function() {
		app.gamePaused = true;
		timer.pause();
		$('#instructions').fadeIn();
	},

	//--------------------
	// Display Game Over modal
	gameOver: function() {
		$('#timesUp').fadeIn();
		$('#gameOverOcto').attr('src','images/octocats/gameover.png');

		firebase.push("matt","@mattmcfad",app.currentLevel, app.score);

	},

	//--------------------
	// Restart the game
	restartGame: function() {
		// Reset Divs
		$('#gamegrid').html('');
		
		timer.pause();

		app.init();
		app.eventListeners();

		$('#timesUp').fadeOut();
	}
			

}; // app

$(document).ready(function(){
	
	app.init();
	firebase.init();
	console.log("over");
	app.eventListeners();

});

//--------------------
// Prototype function that tests if an object is contained in an Array
Array.prototype.contains = function ( needle ) {
		for (var i in this) {
			if (this[i] == needle) return true;
		}
		return false;
};;var octocats = [
	{
		img: 'bear-cavalry.png'
	},
	{
		img: 'daftpunktocat-guy.gif'
	},
	{
		img: 'heisencat.png'
	},
	{
		img: 'homercat.png'
	},
	{
		img: 'ironcat.jpg'
	},
	{
		img: 'murakamicat.png'
	},
	{
		img: 'nyantocat.gif'
	},
	{
		img: 'octobiwan.jpg'
	},
	{
		img: 'spidertocat.png'
	},
	{
		img: 'steroidtocat.png'
	},
	{
		img: 'topguntocat.png'
	},
	{
		img: 'visionary.jpg'
	},
	{
		img: 'xtocat.jpg'
	},
	{
		img: 'riddlocat.png'
	},
	{
		img: 'stormtroopocat.png'
	},
	{
		img: 'okal-eltocat.jpg'
	},
	{
		img: 'dodgetocat_v2.png'
	},
	{
		img: 'daftpunktocat-thomas.gif'
	}

];;
//--------------------
// Countdown timers that uses jQuery-timer library
// Inside function is ran every iteration
// This object was initialized in app.init()
var timer = $.timer(function() {
    $('#countdown').html(formatTime(app.count));

    if (app.count === 0){
    	timer.stop();
    	app.gameOver();
    }
    // Decrement time by 10 milliseconds each iteration
    app.count -= 10;

    // Make sure we hit and stop at 0
    if (app.count < 0) 
    	app.count = 0;

});
//--------------------
// Convert to seconds
function formatTime(ms) {
    return ms / 1000;
}